"""
HeliconFocus integration module for focus stacking.
"""

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
import subprocess
import time
from typing import List, Optional


class Method(Enum):
    """HeliconFocus stacking methods."""
    A = 0
    B = 1
    C = 2


@dataclass
class HeliconConfig:
    """HeliconFocus configuration parameters.
    
    Args:
        radius: Radius parameter for HeliconFocus (1-8)
        smoothing: Smoothing parameter for HeliconFocus (0-4)
        jpeg_quality: JPEG quality if output_format is 'jpg' (1-100)
        output_format: Output format ('jpg', 'tif', or 'dng')
        helicon_path: Path to HeliconFocus executable
    """
    radius: int = 3
    smoothing: int = 1
    jpeg_quality: int = 95
    output_format: str = 'dng'
    helicon_path: str = '/Applications/HeliconFocus.app/Contents/MacOS/HeliconFocus'
    
    def __post_init__(self):
        """Validate configuration parameters."""
        if not 1 <= self.radius <= 8:
            raise ValueError("Radius must be between 1 and 8")
        if not 0 <= self.smoothing <= 4:
            raise ValueError("Smoothing must be between 0 and 4")
        if not 1 <= self.jpeg_quality <= 100:
            raise ValueError("JPEG quality must be between 1 and 100")
        if self.output_format not in ["jpg", "tif", "dng"]:
            raise ValueError("Output format must be 'jpg', 'tif', or 'dng'")
        if not Path(self.helicon_path).exists():
            raise FileNotFoundError(f"HeliconFocus not found at {self.helicon_path}")


def process_stack(
    stack_dir: Path,
    output_dir: Path,
    config: HeliconConfig,
    combine_ab: bool = True
) -> List[Path]:
    """Process a stack with Helicon Focus using methods A, B, C.
    
    This function processes a stack of images using different HeliconFocus methods.
    It checks for existing results and only processes missing methods. If combine_ab
    is True, it will also create an A+B combination using method B.
    
    Args:
        stack_dir (Path): Directory containing stack images
        output_dir (Path): Directory for output images
        radius (int, optional): Radius parameter for HeliconFocus. Defaults to 3.
        smoothing (int, optional): Smoothing parameter for HeliconFocus. Defaults to 1.
        jpeg_quality (int, optional): JPEG quality (1-100). Defaults to 95.
        output_format (str, optional): Output format (jpg, tif or dng). Defaults to 'dng'.
        helicon_path (str, optional): Path to HeliconFocus executable.
        combine_ab (bool, optional): Whether to combine methods A and B. Defaults to True.
    
    Returns:
        List[Path]: List of output files generated by HeliconFocus.
    
    Note:
        The function creates a HeliconConfig object internally to manage configuration
        parameters. It uses the Method enum to handle different stacking methods.
    """
    print(f"\nüíæ Starting HeliconFocus for {stack_dir.name}")
    
    # Create output directory if it doesn't exist
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Create input.txt with list of source files
    input_file = stack_dir / "input.txt"
    try:
        # Import ImageFormat here to avoid circular imports
        from focus_stack_sorter import ImageFormat
        
        # Get all supported formats
        formats = [f"*.{ext[1:]}" for ext in ImageFormat.all_extensions()]
        formats.extend([f"*.{ext[1:].upper()}" for ext in ImageFormat.all_extensions()])
        
        # Build command to find all supported image files
        format_pattern = ' '.join(formats)
        cmd = f"cd {stack_dir.absolute()} && (ls {format_pattern} 2>/dev/null || true) | sed 's|^|{stack_dir.absolute()}/|' > {input_file.absolute()}"
        subprocess.run(
            cmd,
            shell=True,
            check=True
        )
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Failed to create input file: {e}")
        return []
    
    # Ensure config is valid
    if not isinstance(config, HeliconConfig):
        raise TypeError("config must be a HeliconConfig instance")
    
    # Check which methods already exist
    existing_methods = []
    missing_methods = []
    results = []
    
    # Check which output files already exist
    for method in Method:
        output_file = output_dir / f"{stack_dir.name}_{method.name}.{output_format}"
        if output_file.exists():
            existing_methods.append(method)
            results.append(output_file)
        else:
            missing_methods.append(method)
    
    if existing_methods:
        print(f"\nüí° Found existing results for methods: {', '.join(m.name for m in existing_methods)}")
        print(f"üîÑ Will generate missing methods: {', '.join(m.name for m in missing_methods)}")
    
    # Process missing methods
    for method in missing_methods:
        output_file = output_dir / f"{stack_dir.name}_{method.name}.{output_format}"
        
        # Create command line for HeliconFocus
        cmd = [
            config.helicon_path,
            '-silent',
            '-i', str(input_file),
            f'-save:{output_file}',
            f'-mp:{method.value}',  # Method parameter (A=0, B=1, C=2)
            f'-rp:{config.radius}',  # Radius parameter
            f'-sp:{config.smoothing}'  # Smoothing parameter
        ]
        
        # Add JPEG quality only for JPG output
        if config.output_format.lower() == 'jpg':
            cmd.append(f'-j:{config.jpeg_quality}')
        
        print(f"\nüì¶ Processing {stack_dir.name} with Method {method.name}...")
        start_time = time.time()
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                results.append(output_file)
                elapsed = time.time() - start_time
                print(f"‚úÖ Method {method.name} completed successfully in {elapsed:.2f} seconds")
            else:
                print(f"‚ùå Error with Method {method.name}: {result.stderr}")
        except Exception as e:
            print(f"‚ùå Failed to run HeliconFocus: {e}")
    
    # Only process A+B combination if requested
    if combine_ab:
        # Check if A+B combination already exists
        ab_file = output_dir / f"{stack_dir.name}_AB.{output_format}"
        if ab_file.exists():
            print("\nüí° A+B combination already exists")
            results.append(ab_file)
            return results
        
        # Combine A and B using method B if both exist
        all_methods = existing_methods + missing_methods
        if Method.A in all_methods and Method.B in all_methods:
            a_file = output_dir / f"{stack_dir.name}_A.{output_format}"
            b_file = output_dir / f"{stack_dir.name}_B.{output_format}"
            # Create new input.txt for A+B combination
            ab_input = stack_dir / "input_ab.txt"
            with open(ab_input, 'w') as f:
                f.write(f"{a_file.absolute()}\n{b_file.absolute()}\n")
            
            ab_file = output_dir / f"{stack_dir.name}_AB.{output_format}"
            
            # Create command line for HeliconFocus
            cmd = [
                config.helicon_path,
                '-silent',
                '-i', str(ab_input),
                f'-save:{ab_file}',
                '-mp:1',  # Method B for combination
                f'-rp:{config.radius}',
                f'-sp:{config.smoothing}'
            ]
            
            # Add JPEG quality only for JPG output
            if config.output_format.lower() == 'jpg':
                cmd.append(f'-j:{config.jpeg_quality}')
            
            print("\nüí∂ Combining methods A and B...")
            start_time = time.time()
            try:
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0:
                    results.append(ab_file)
                    elapsed = time.time() - start_time
                    print(f"‚úÖ A+B combination completed successfully in {elapsed:.2f} seconds")
                else:
                    print(f"‚ùå Error combining A+B: {result.stderr}")
            except Exception as e:
                print(f"‚ùå Failed to combine A+B: {e}")
            
            # Clean up AB input file
            try:
                ab_input.unlink()
            except Exception:
                pass
    
    # Clean up original input file
    try:
        input_file.unlink()
    except Exception:
        pass
    
    return results
